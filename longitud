				.data
ficheroEntrada: .asciiz "/Users/hmcshan/Desktop/tester.txt" 
ficheroSalida: .asciiz "c:\users\ficheroS.txt"
buffer:			.space 1
eError:			.asciiz "Error al abrir el fichero de entrada"
sError:			.asciiz "Error al crear el fichero de salida"
error_vacio:		.asciiz "Fichero Vacio"

			.text
				.globl main
				
main:			la $a0 ficheroEntrada	#abrimos el fichero
			li $a1 0x0
			li $v0 13
			syscall
			li $t0 -1
			beq $v0 $t0 error
			
			move $s0 $v0	#copiamos el descriptor del ficheroEntrada	#$s0 descriptor del archivo
		
				
bucle:			move $a0 $s0	#lee 1 caracter
			la $a1 buffer
			li $a2 1
			li $v0 14
			syscall
			
			beqz $v0 vacio	#si ha terminado el archivo terminamos el programa
				
			lb $t0 buffer	#comprobamos si es un espacio o un salto de linea	 #$t0 caracter en buffer
				
			li $t1 0x13
			beq $t1 $t0 bucle
			li $t1 0x20
			beq $t1 $t0 bucle

			move $a0 $t0	#si no lo es seguimos, pasamos el caracter leido como parametro
				
			addi $sp $sp -8	#guardamos en la pila el $ra y el $fp
			sw $ra 4($sp)
			sw $fp ($sp)
				
			jal longitud	#llamamos a la funcion
				
			lw $fp ($sp)	#recuperamos el $fp y el $ra
			lw $ra 4($sp)
			addi $sp $sp 8

					#call list writer function***************************************************
				
			bnez $v0 bucle	#comprobamos si en el subprograma o en el descarte de espacios ha llegado al final
			
			move $a0 $s0	#cerramos el archivo y terminamos el programa
			li $v0 16
			syscall		
					#open file*******************************************************************
					#check for error*************************************************************
					#write to file***************************************************************
					#close file******************************************************************					
			b finPrograma
				
error:			la $a0 	eError	#sacamos por pantalla el mensaje de error
			li $v0 4
			syscall
			li $v0 10
			syscall
				
longitud:		li $v1 1	#nuestra funcion 	#iniciamos variables	#contador de longitud de la palabra
				
bucleChar:		move $a0 $s0	#leemos un caracter
			la $a1 buffer
			li $a2 1
			li $v0 14
			syscall
			
			beqz $v0 fin	#si ha llegado al final del archivo terminamos la funcion
			lb $t1 buffer	#guardamos el caracter leido		#$t1 caracter leido del archivo
			
			li $t3 0x13	#si el ultimo caracter leido es un espacio o un enter salimos de bucle
			beq $t1 $t3 fin
			li $t3 0x20
			beq $t1 $t3 fin
						
			addi $v1 $v1 1	#incrementamos contador de longitud de palabra
			b bucleChar


fin:			move $a0 $v1
			li $v0 1
			syscall
			jr $ra		

vacio:			li $v0 4
			la $a0 error_vacio
			syscall 
			li $v0 10
			syscall

finPrograma:	        li $v0 1
			move $a0 $s1
			syscall
			li $v0 10
			syscall
